//배고파(Easy)
//**********/
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
    
    int n;
    
    scanf("%d", &n);
    
    while (n--) {
        long long m;
        
        scanf("%lld", &m);
        
        if (m % 2 == 0) {
        
            long long mid = m / 2;
        
            if (mid > 0 && (mid & (mid - 1)) == 0) {
        
                int k = 0;
        
                while ((1LL << k) != mid)
        
                    k++;

                printf("%d %d\n", k, k);
            
                continue;
            }
        }
        
        int bit[2], id = 0;
        
        for (int j = 0; j < 64; j++) {
        
            if (m & (1LL << j)) {
        
                bit[id++] = j;
        
                if (id == 2) 
        
                    break;
            }
        
        }
        
        printf("%d %d\n", bit[0], bit[1]);
    
    }

    return 0;

}
/*
메뉴의 개수를 입력합니다. 
메뉴의 개수에 따라 조건문이 반복됩니다. while(n--)는 n이 1씩 줄다가 0에 도달하면 종료되게 합니다.
m이 매우 커질 수 있습니다. 따라서 long long 자료형을 사용합니다.
m이 2의 배수인 경우 x와 y가 같아질 수 있습니다.
m이 0보다 크고 2의 거듭제곱인지 판별하기위해 mid & (mid -1) 연산을 진행합니다.
이때 mid가 예를들어 8인 경우 1000 이고 mid -1은 0111이 됩니다. 이를 AND 연산한다면
0이 출력됩니다. 즉, 8은 2의 거듭제곱근이라는 것을 찾을 수 있습니다.
또다른 예) m = 512 -> mid = 256 (100000000) mid - 1 = 011111111 AND 연산 => 0
mid가 2의 거듭제곱근이라는 것이 확인되면 지수 k를 찾기 위해 조건문을 실행합니다.
1LL << k는 2^k가 mid와 같아질 때까지 k를 1씩 증가시킵니다. 1LL << k는 2의 거듭제곱근을 계산합니다.
예를 들어 k가 0인 경우 1LL << k를 진행하면 0000에서 0001이 됩니다. long long 타입을 사용했으므로 비트 쉬프트시 1LL을 사용합니다.
마찬가지로 k가 1인 경우 0001에서 1LL << k 연산을 통해 0010이 됩니다. 즉, 0이었던 것이 1이되고 1이었던 것이 2가 됩니다.
이 연산을 통해 2의 지수 k를 얻을 수 있습니다.
k값을 찾았다면 이는 2의 거듭제곱근의 지수 즉, x와 y의 값이 됩니다. 따라서 그 값을 출력합니다.
continue를 작성해 2의 거듭제곱근의 값이 들어온 특수 상황이 발생 시 아래의 일반로직을 건너뛰고
다음 케이스를 시작하게끔 합니다.
이제 일반적인 케이스 즉, x와 y의 값이 다를 수 있습니다.
찾은 두 개의 지수를 저장할 배열과 인덱스를 선언합니다.
longlong 타입은 64비트이므로 0비트부터 63비트까지 하나씩 성분을 검사해야합니다. 따라서 for 조건문은
64번 돌 수 있게 작성합니다.
1LL << j는 1비트를 (....0001) 왼쪽으로 j비트 만큼 밀어서 j위치에만 1을 갖게끔 합니다.
예를 들어 j가 3이라면 00000000 00000000 00000000 00000001이었던 것이
00000000 00000000 00000000 00001000 이 됩니다. 이는 8이고 2의 3제곱입니다.
즉, 위 과정을 거친 비트 마스크가 우리가 입력한 m과 AND연산을 진행해서 1이 생긴 부분은
m이 비트 마스크의 성분을 지니고 있다는 것을 의미합니다.
비트 마스킹 조건문을 충족하는 j는 bit배열에 id인덱스로 적재됩니다. 이때 배열의 j값이 적재될 때마다
id는 1씩 증가하고 id가 2가 되었다는 것은 m의 모든 성분을 추출했다는 것이고 m은 2^x + 2^y의 구조를 가지므로
2개의 값이 들어오면 m성분을 모두 추출한다는 것은 당연하게 되고 X와 Y의 값을 얻게 됩니다.


*/
